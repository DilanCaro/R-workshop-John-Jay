# Workshop 1 {-}

## Exercise solutions {-}

## Exercise 1 {-}

### 1 Run the following code, then use typeof(), class() functions to find out the data type and/or class object. {-}

```{r}
my_numeric <- 42.5
John_jay <- "university"
my_logical <- TRUE
my_date <- as.Date("05/29/2018", "%m/%d/%Y")
# for date
typeof(my_date)
class(my_date)
# for numeric
typeof(my_numeric)
class(my_numeric)
# for char
typeof(John_jay)
class(John_jay)
#for logical
typeof(my_logical)
class(my_logical)
```

### 2  What is the difference between typeof() and class()? {-}


Here we can see that `typeof(my_date)` is a double, and `class(my_date)` is `Date`. This is because `typeof` output the lowest level data type of the object. While `class` outputs the class of the object. 

If you are writing code that involves checking whether an element is of an specific data type , then you need to be careful on how you check that. Depending on the function , it may give you a true value when in reality you want a false value to be returned. 

For example, Imagine you are asked to check if all dates in a dateframe have the correct data type. 

In some cases it might be `"05/29/2018"` but in a rare case (maybe due to a data entry error), there is a `"42.5"`
```{r}
typeof(my_date) == typeof(my_numeric)
```

In the previous comparison , it returns true, meaning that the two data types are the same, maybe youu thought you are comparing if both are date type, but in reality , you are comparing the lowest level data types which are indeed equal (double)

Instead, you should do.

```{r}
class(my_date) == class(my_numeric)
```

### 3. Create 1 datatype of each: Character, numeric, integer, complex, Boolean  {-}

The answers may vary . Below an example of a solution,

```{r}

Best_university_in_nyc <- "John Jay"
Best_university_in_nyc
My_gpa <- 3.78
My_gpa
My_int_gpa <- as.integer(My_gpa)
My_int_gpa
my_complex_gpa<- 3.78+2i
my_complex_gpa
do_I_like_chocolate_ice_cream <- FALSE
do_I_like_chocolate_ice_cream

my_elements =list(Best_university_in_nyc,My_gpa,My_int_gpa,my_complex_gpa,do_I_like_chocolate_ice_cream)

# Check the classes of each element
for (element in my_elements) {
  print(class(element))
}
```

## Exercise 2 {-}

### 4. Create a vector of your favorite numbers. {-}

```{r}
my_favorite_numbers <- c(7,22,17,19)
```

### 5. Access the third element in your vector. {-}
```{r}
my_favorite_numbers[3]
```

Note that R starts indexing from 1. This is somewhat more natural since we start counting at 1 . However, most programming languages start indexing at 0, that is, to access the third element it would be `my_favorite_numbers[2]` in a language like python . 

### 6. Create a new vector that is the square of each element in the original vector. {-}

```{r}
square_favorite_numbers<- my_favorite_numbers^2
square_favorite_numbers
```

### 7. 

```{r}
my_vector <- c("Katrien Antonio", "teacher")
names(my_vector) <- c("Name", "Profession")
my_vector
```


```{r}
attributes(my_vector)
```

```{r}
length(my_vector)
```
```{r}
names(my_vector)
```

## Exercise 3

### 8. Create a data frame with at least three columns and four rows. {-}

```{r}
df <- data.frame(
  Subject = c("Art", "Bayesian", "Machine learning", "Stochastic"),
  Grade =c(100,87,90,75),
  Difficulty =c(6,9,8,10)# from 0 to 5 , 5 being the most difficuly
  )
print(df)
```

### 9. Print the number of rows and columns of your data frame. {-}

```{r}
print(dim(df)) 
```

That shows 4 rows, and 3 columns 

### 10. Display summary statistics of your data frame. {-}

```{r}
print(summary(df))
```

## Part 2{-}

Inspect a built-in data frame
```{r}
mtcars
str(mtcars)
head(mtcars)
```

Get summary from a variable in a dataframe

```{r}
summary(mtcars$cyl) # use $ to extract variable from a data frame
```

Now inspect a tibble

```{r}
library(ggplot2)
diamonds
str(diamonds)  # built-in in library ggplot2
head(diamonds)
summary(diamonds$depth)
```

## Exercise 4 {-}

1. Create a vector `fav_music` with the names of your favorite artists.
2. Create a vector `num_records` with the number of records you have in
your collection of each of those artists.
3. Create a vector `num_concerts` with the number of times you attended a concert of these artists.
4. Put everything together in a data frame, assign the name `my_music` to this data frame and change the labels of the information stored in the columns to `artist`, `records` and `concerts.`
5. Extract the variable `num_records` from the data frame `my_music.`
6. Calculate the total number of records in your collection (for the defined
set of artists).
7. Check the structure of the data frame, ask for a `summary.`

```{r}
fav_music <- c("Prince", "REM", "Ryan Adams", "BLOF")
num_concerts <- c(0, 3, 1, 0)
num_records <- c(2, 7, 5, 1)
my_music <- data.frame(fav_music, num_concerts, num_records)
names(my_music) <- c("artist", "concerts", "records")
summary(my_music)
my_music$records
sum(my_music$records)
```


### Import other data formats {-}

The `haven` package enables R to read and write various data formats used by other statistical packages. 

It supports:

- SAS: `read_sas()` reads .sas7bdat and .sas7bcat files and `read_xpt()` reads SAS transport files. write_sas() writes .sas7bdat files.
- SPSS: `read_sav()` reads .sav files and `read_por()` reads the older .por files. write_sav() writes .sav files.
- Stata: `read_dta()` reads .dta files. `write_dta()` writes .dta files.

### Exercise 5 {-}

Load the following data sets, available in the course material: 
- the Danish fire insurance losses, stored in `danish.txt`
- the severity data set, stored in `severity.sas7bdat`.

```{r}
path <- file.path('./John Jay Workshop Data')
path.danish <- file.path(path, "danish.txt")
danish <- read.table(path.danish, header = TRUE)
danish$Date <- as.Date(danish$Date, "%m/%d/%Y")
str(danish)
```

```{r}
library(haven)
severity <- read_sas('./John Jay Workshop Data/severity.sas7bdat')
str(severity)
```



