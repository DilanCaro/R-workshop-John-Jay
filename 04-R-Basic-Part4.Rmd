# Part IV: Data Manipulation (30 minutes) {-}

## Subsetting and filtering data {-}

Subsetting and filtering data involve selecting specific elements, rows, or columns from a dataset based on certain conditions or criteria. In R, subsetting can be achieved using square brackets `[]`, the `subset()` function, or dplyr package functions like `filter()` for rows and `select()` for columns. Filtering refers more specifically to choosing rows that meet certain conditions, such as values within a range or matching specific characteristics.

```{r}
# Creating a sample data frame
data <- data.frame(
  id = 1:5,
  name = c("Alice", "Bob", "Charlie", "David", "Eva"),
  age = c(25, 30, 22, 28, 24)
)
# Subsetting by a specific column
ages <- data$age
print(ages)

# Filtering data based on a condition
young_adults <- subset(data, age < 30)
print(young_adults)

```

### Using the dplyr package {-}

The `%>%` symbol in R is known as the pipe operator, and it's used to pass the result of one expression as the first argument to the next expression

1. Filtering data using dplyr for individuals younger than 30

```{r}
library(dplyr)
young_adults <- data %>% filter(age < 30)
print(young_adults)

```
2. Subsetting columns using dplyr

```{r}
ages <- data %>% select(age)
print(ages)
```


## Adding, removing, and renaming columns {-}

1. Adding a new column 'salary'

```{r}
data$salary <- c(55000, 50000, 60000, 52000, 58000)
print(data)
```

2. Removing the 'salary' column

```{r}
data$salary <- NULL
print(data)
```

3. Renaming the 'name' column to 'first_name'

```{r}
names(data)[names(data) == "name"] <- "first_name"
print(data)
```


## Using the dplyr package {-}

```{r, echo= FALSE}
# Creating a sample data frame
data <- data.frame(
  id = 1:5,
  name = c("Alice", "Bob", "Charlie", "David", "Eva"),
  age = c(25, 30, 22, 28, 24)
)
```

1. Adding a new column 'salary' using mutate

```{r}
data <- data %>%
  mutate(salary = c(55000, 50000, 60000, 52000, 58000))
print(data)
```

2. Removing the 'salary' column using select

```{r}
data <- data %>%
  select(-salary)
print(data)
```

3. Renaming the 'name' column to 'first_name' using rename

```{r}
data <- data %>%
  rename(first_name = name)
print(data)
```

## Why use dyplr {-}

One might think that using pipe operator `(%>%)` from the `magrittr` package, prominently used in dplyr and the wider tidyverse is unnecessarily more complex. While it may seem more complex at first, especially to those accustomed to base R functions and syntax, it offers several benefits that can greatly enhance the readability, efficiency, and overall workflow of data analysis. Some reasons to use it are:

1. Improved Readability and Clarity
2. Easier Debugging and Modification
3. Enhanced Workflow
4. Consistency and Community Adoption
5. Efficiency in Writing Code

An example of the benefits is seen in more complex operations making them more readable

Let's just add salary column again.

```{r, echo= FALSE}
# Creating a sample data frame
data <- data.frame(
  id = 1:5,
  name = c("Alice", "Bob", "Charlie", "David", "Eva"),
  age = c(25, 30, 22, 28, 24)
)
```



```{r}
data$salary <- c(55000, 50000, 60000, 52000, 58000)
subsetting_data <- rename(select(
                          filter(data, age < 30), -salary),
                          first_name = name)
subsetting_data
```

Now, doing it using dplyr

```{r}

data <- data %>%
  mutate(salary = c(55000, 50000, 60000, 52000, 58000))

data <- data %>%
  filter(age < 30) %>%
  select(-salary) %>%
  rename(first_name = name)
data
```


## Basic data summary and exploration {-}

A very brief summary and data exploration is given below.

1. Summary statistics of the data frame

```{r}
summary(data)
```

2. Structure of the data frame

```{r}
str(data)
```

3. Average age of the individuals in the data frame

```{r}
average_age <- mean(data$age)
print(average_age)
```

4. Count of unique names in the data frame

```{r}
unique_names_count <- length(unique(data$first_name))
print(unique_names_count)
```


## Exploratory data analysis {-}

Exploratory Data Analysis (EDA) is a critical initial step in the data analysis process, where the main characteristics of a dataset are examined to understand its structure, uncover patterns, identify anomalies, and test hypotheses. The goal is to use statistical summaries and visualizations to get a sense of the data, which guides further analysis and modeling decisions. EDA is not about making formal predictions or testing hypotheses but rather about asking questions and seeking insights in a more open-ended, exploratory manner.

**Key Components of EDA include:**

- **Understanding the Distribution** of various variables in the dataset. This involves looking at measures like mean, median, mode, range, variance, and standard deviation, and using visual tools like histograms, box plots, and density plots to understand how the data is spread out.

- **Identifying Patterns** and Relationships between variables using scatter plots, pair plots, and correlation matrices. This helps in understanding how variables are related to each other and can guide more complex analyses like regression or classification.

- **Detecting Anomalies** such as outliers or unexpected values which might indicate errors in data collection or provide insights into unusual occurrences in the data.

- **Cleaning Data** by addressing missing values, duplicate data, and making decisions about how to correct inconsistencies based on the insights gained.

- **Transforming Variables** when necessary to make the data more suitable for analysis. This could involve normalizing the data, creating categorical variables from continuous ones, or engineering new variables from existing ones.

**Tools and Techniques**

Statistical Summary Functions in R (`summary()`, `mean()`, `sd()`, etc.) provide quick insights into the basic properties of the data.

Visualization Libraries like `ggplot2` in R for creating a wide range of plots and charts that reveal the underlying patterns and structures in the data.

**Importance of EDA**

- **Data Understanding:** It ensures that the analyst has a thorough understanding of the dataset's features, values, and relationships between variables.

- **Guiding Hypotheses:** Insights gained during EDA can help form hypotheses for statistical testing and predictive modeling.

- **Modeling Strategy:** Identifying the key variables and their relationships helps in choosing appropriate models and techniques for further analysis.

In summary, EDA is an essential practice in data science for making sense of data, discovering patterns, identifying potential problems, and informing subsequent steps in the analytical process. It blends statistical techniques with visual explorations to create a foundation for any data-driven task.


Now we will explore a dataset from the library `AER` , and a numeric variable first

## Numeric Variable {-}

```{r}
#install.packages("AER")
library(AER)
data("CPS1985")
str(CPS1985)
```

```{r}
head(CPS1985)
```

Obtain the summary statistics of the data frame, check whether it is numeric, get the mean , and variance.

```{r}
summary(CPS1985$wage)
is.numeric(CPS1985$wage)
mean(CPS1985$wage)
var(CPS1985$wage)
```

Now, visualize the `wage` distribution


```{r}
hist(log(CPS1985$wage), freq = FALSE, nclass = 20, col = "light blue")
lines(density(log(CPS1985$wage)), col = "red")
```

## A factor variable {-}

You now explore the occupation variable 

```{r}
summary(CPS1985$occupation)
```

change the names of some of the levels

```{r}
levels(CPS1985$occupation)[c(2, 6)] <- c("techn", "mgmt")
summary(CPS1985$occupation)
```

visualize the distribution

```{r}
tab <- table(CPS1985$occupation)
prop.table(tab)
barplot(tab)
pie(tab, col = gray(seq(0.4, 1.0, length = 6)))
```

## Two factor variables {-}

You now explore the factor variables `gender` and `occupation.` 

Use `prop.table()`

The `prop.table()` function in R is used to compute the proportion of table elements over the margin specified (if any). When applied to a contingency table created by the table() function, it transforms the table's counts into proportions, making it easier to analyze the relative distribution of frequencies across different categories.

```{r}
attach(CPS1985) # attach the data set to avoid use the operator $
table(gender, occupation) # no name_df$name_var necessary
```

```{r}
prop.table(table(gender, occupation))
```

Now try `prop.table(table(gender, occupation), 2)`

```{r}
prop.table(table(gender, occupation), 2) # 1 for row , 2 for columns
```
 



You now explore the factor variables gender and occupation. 

Do a mosaic plot


A mosaic plot, also known as a Marimekko diagram or a mosaic chart, is a graphical representation of data that allows for the visualization of the proportions or frequencies of categorical variables in a dataset. It's a type of plot that provides a visual summary of the contingency table associated with two or more categorical variables. Each rectangle (tile) in the mosaic plot represents a combination of category levels from the variables, with the area of the rectangle proportional to the frequency or proportion of observations in that category combination.


```{r}
plot(gender ~ occupation, data = CPS1985)
```
 
Now explore the factor gender and the numeric variable wage.
 
 The `tapply()` function in R is used to apply a function to subsets of a vector, where subsets are defined by some other vector, usually a factor. The basic syntax of tapply() is:
 
- X is the object to be split and operated on.
- INDEX is the factor or list of factors according to which X is split.
- FUN is the function to be applied to each subset of X.
- ... are optional arguments to FUN.
- simplify, when TRUE, tries to simplify the result to a vector, matrix, or higher-dimensional array; when FALSE, the result is a list.

```{r}
tapply(wage, gender, mean)
```
 
```{r}
tapply(log(wage), list(gender, occupation), mean)
```
 
## A factor and a numeric variable {-}

Explore a factor variable and a numeric variable. 
Visualize the distribution of `wage` per `gender`

```{r}
boxplot(log(wage) ~ gender, data = CPS1985)
```

 Now try with
 
```{r}
boxplot(log(wage) ~ gender + occupation, data = CPS1985)
```
 
```{r}
detach(CPS1985) # now detach when work is done
```

